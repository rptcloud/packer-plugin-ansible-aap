package main

import (
	"context"
	"fmt"
	"os"

	"github.com/rptcloud/packer-provisioner-ansible-aap/pkgs/client"
	"github.com/rptcloud/packer-provisioner-ansible-aap/pkgs/config"

	"github.com/hashicorp/hcl/v2/hcldec"
	packersdk "github.com/hashicorp/packer-plugin-sdk/packer"
	"github.com/hashicorp/packer-plugin-sdk/plugin"
	sdkconfig "github.com/hashicorp/packer-plugin-sdk/template/config"
	"github.com/hashicorp/packer-plugin-sdk/version"
)

var pluginVersion = "1.0.0" // overridden by goreleaser

type Provisioner struct {
	config config.Config
	client *client.AAPClient
}

// Resource IDs for cleanup.
type ResourceIDs struct {
	InventoryID  int
	HostID       int
	CredentialID int
	JobID        int
}

func main() {
	pps := plugin.NewSet()
	pps.SetVersion(version.NewPluginVersion(pluginVersion, "", ""))
	pps.RegisterProvisioner(plugin.DEFAULT_NAME, new(Provisioner))
	if err := pps.Run(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

// 1) Define your HCL schema.
func (p *Provisioner) ConfigSpec() hcldec.ObjectSpec {
	// FlatMapstructure is generated by `packer-sdc mapstructure-to-hcl2`
	return p.config.FlatMapstructure().HCL2Spec()
}

// 2) Decode raw HCL into p.config, then validate.
func (p *Provisioner) Prepare(raws ...interface{}) error {
	if err := sdkconfig.Decode(&p.config, &sdkconfig.DecodeOpts{
		PluginType:  "provisioner",
		Interpolate: true,
	}, raws...); err != nil {
		return err
	}
	return p.config.Validate()
}

// 3) Initialize any clients you need.
func (p *Provisioner) Configure(_ ...interface{}) {
	p.client = client.NewAAPClient(p.config)
}

func (p *Provisioner) Provision(
	ctx context.Context,
	ui packersdk.Ui,
	comm packersdk.Communicator,
	generatedData map[string]interface{},
) error {
	// Initialize resource tracking for cleanup
	resources := &ResourceIDs{}

	// Ensure cleanup happens even if we exit early
	defer p.cleanup(ctx, ui, resources)

	// Extract connection details from generated data
	host := "localhost"
	if h, ok := generatedData["Host"].(string); ok && h != "" {
		host = h
	}

	port := 22
	if p, ok := generatedData["Port"].(int); ok && p != 0 {
		port = p
	}

	username := "ec2-user"
	if u, ok := generatedData["User"].(string); ok && u != "" {
		username = u
	}

	// If we have WinRM password but port is still 22, we need to use WinRM port
	if winRMPass, hasWinRMPass := generatedData["WinRMPassword"].(string); hasWinRMPass && winRMPass != "" && port == 22 {
		port = 5985 // Override to WinRM HTTP port
		ui.Message(fmt.Sprintf("üîß Detected WinRM connection, but port detected as 22, overriding port to %d", port))
	}

	// Initialize client if not already done
	ui.Message(fmt.Sprintf("üåê Attempting to connect to AAP server: %s", p.config.TowerHost))
	if p.client == nil {
		ui.Message("üîß Initializing AAP client...")
		p.client = client.NewAAPClient(p.config)
		if p.client == nil {
			ui.Error("‚ùå AAP client initialization returned nil")
			return fmt.Errorf("failed to initialize AAP client")
		}
		ui.Message("‚úÖ AAP client initialized successfully")
	} else {
		ui.Message("‚úÖ AAP client already initialized")
	}

	// Create inventory
	ui.Message(fmt.Sprintf("üéØ Creating inventory for target host: %s", host))
	ui.Message(fmt.Sprintf("üóÑÔ∏è Using organization ID: %d", p.config.OrganizationID))
	inventoryID, err := p.client.CreateInventory(ctx, p.config.OrganizationID)
	if err != nil {
		ui.Error(fmt.Sprintf("‚ùå Failed to create inventory: %s", err))
		ui.Error(fmt.Sprintf("üîç This might be a network connectivity issue to %s", p.config.TowerHost))
		return fmt.Errorf("failed to create inventory: %s", err)
	}
	resources.InventoryID = inventoryID
	ui.Message(fmt.Sprintf("‚úÖ Created inventory with ID: %d", inventoryID))

	// Create credential if needed
	// User might not want to create a credential because they set ask_credential_on_launch to false
	var credentialID int
	var credentialType string
	if p.config.CreateCredential {
		// Windows should go first because its possible to have both SSH and WinRM credentials
		if winrmPassword, ok := generatedData["WinRMPassword"].(string); ok && winrmPassword != "" {
			// Create WinRM credential with password
			ui.Message("üîë Creating WinRM credential with password...")
			credentialID, err = p.client.CreateWinRMCredential(ctx, p.config.OrganizationID, username, winrmPassword)
			if err != nil {
				ui.Error(fmt.Sprintf("failed to create WinRM credential: %s", err))
				return fmt.Errorf("failed to create WinRM credential: %s", err)
			}
			resources.CredentialID = credentialID
			credentialType = "winrm_password"
			ui.Message(fmt.Sprintf("‚úÖ Created WinRM credential ID: %d", credentialID))
		} else if privateKey, ok := generatedData["SSHPrivateKey"].(string); ok && privateKey != "" {
			// Create SSH credential with private key
			credentialID, err = p.client.CreateCredential(ctx, p.config.OrganizationID, username, privateKey)
			if err != nil {
				ui.Error(fmt.Sprintf("failed to create SSH credential: %s", err))
				return fmt.Errorf("failed to create SSH credential: %s", err)
			}
			resources.CredentialID = credentialID
			credentialType = "ssh_key"
			ui.Message(fmt.Sprintf("‚úÖ Created SSH credential ID: %d", credentialID))
		} else if password, ok := generatedData["Password"].(string); ok && password != "" {
			// Create SSH credential with password
			ui.Message("üîë Creating SSH credential with password...")
			credentialID, err = p.client.CreatePasswordCredential(ctx, p.config.OrganizationID, username, password)
			if err != nil {
				ui.Error(fmt.Sprintf("failed to create password credential: %s", err))
				return fmt.Errorf("failed to create password credential: %s", err)
			}
			resources.CredentialID = credentialID
			credentialType = "ssh_password"
			ui.Message(fmt.Sprintf("‚úÖ Created password credential ID: %d", credentialID))
		} else {
			ui.Error("‚ùå No authentication method found in generated data (SSHPrivateKey, Password, or WinRMPassword)")
			return fmt.Errorf("no authentication method found in generated data")
		}
	}

	// Add host to inventory
	ui.Message(fmt.Sprintf("üñ•Ô∏è Adding host %s to inventory", host))
	hostID, err := p.client.CreateHost(ctx, inventoryID, client.HostDetails{
		Host:     host,
		Port:     port,
		Username: username,
	}, credentialType)
	if err != nil {
		ui.Error(fmt.Sprintf("failed to add host: %s", err))
		return fmt.Errorf("failed to add host: %s", err)
	}
	resources.HostID = hostID
	ui.Message(fmt.Sprintf("‚úÖ Added host ID: %d", hostID))

	// Launch job
	ui.Message(fmt.Sprintf("üöÄ Launching job template ID %d for target_host=%s", p.config.JobTemplateID, host))

	jobID, err := p.client.LaunchJob(ctx, inventoryID, p.config.JobTemplateID, 0, credentialID, p.config.ExtraVars)
	if err != nil {
		ui.Error(fmt.Sprintf("failed to launch job: %s", err))
		return fmt.Errorf("failed to launch job: %s", err)
	}
	resources.JobID = jobID
	ui.Message(fmt.Sprintf("‚úÖ Job launched %s/execution/jobs/playbook/%d/output/. Waiting for completion...", p.config.TowerHost, jobID))
	defer func() {
		stdout, err := p.client.GetJobStdout(ctx, jobID)
		if err != nil {
			ui.Message(fmt.Sprintf("‚ö†Ô∏è %s", err))
		} else {
			ui.Message(stdout)
		}
	}()

	// Poll job status
	ui.Message("‚è≥ Polling job status...")
	err = p.client.PollJob(ctx, jobID, p.config.Timeout, p.config.PollInterval)
	if err != nil {
		return fmt.Errorf("job failed: %s", err)
	}

	ui.Message("üéâ Job completed successfully!")
	return nil
}

// cleanup performs cleanup of created resources in dependency-safe order.
func (p *Provisioner) cleanup(ctx context.Context, ui packersdk.Ui, resources *ResourceIDs) {
	// Cleanup in dependency-safe order: credential, host, inventory
	if resources.CredentialID != 0 && !p.config.KeepTempCredential && p.config.CreateCredential {
		ui.Message(fmt.Sprintf("üßπ Cleaning up credential %d...", resources.CredentialID))
		if err := p.client.DeleteCredential(ctx, resources.CredentialID); err != nil {
			ui.Message(fmt.Sprintf("‚ö†Ô∏è Failed to delete credential: %s", err))
		}
	}

	if resources.HostID != 0 {
		ui.Message(fmt.Sprintf("üßπ Cleaning up host %d...", resources.HostID))
		if err := p.client.DeleteHost(ctx, resources.HostID); err != nil {
			ui.Message(fmt.Sprintf("‚ö†Ô∏è Failed to delete host: %s", err))
		}
	}

	if resources.InventoryID != 0 && !p.config.KeepTempInventory {
		ui.Message(fmt.Sprintf("üßπ Cleaning up inventory %d...", resources.InventoryID))
		if err := p.client.DeleteInventory(ctx, resources.InventoryID); err != nil {
			ui.Message(fmt.Sprintf("‚ö†Ô∏è Failed to delete inventory: %s", err))
		}
	}
}

// 5) A no‚Äêop Cancel.
func (p *Provisioner) Cancel() error {
	return nil
}
